{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://wos-api/variables.ts","ng://wos-api/configuration.ts","ng://wos-api/api/locations.service.ts","ng://wos-api/api/stories.service.ts","ng://wos-api/api/users.service.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","export interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length == 0) {\n            return undefined;\n        }\n\n        let type = contentTypes.find(x => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length == 0) {\n            return undefined;\n        }\n\n        let type = accepts.find(x => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/**\n * World_of_Stories-Api\n * Interactive stories application for NodeJs typescript server\n *\n * OpenAPI spec version: 1.0.0\n * \n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\n\nimport { Observable }                                        from 'rxjs';\n\nimport { RequestDeleteCity } from '../model/requestDeleteCity';\nimport { RequestDeletePlace } from '../model/requestDeletePlace';\nimport { RequestGetCities } from '../model/requestGetCities';\nimport { RequestGetCity } from '../model/requestGetCity';\nimport { RequestGetPlace } from '../model/requestGetPlace';\nimport { RequestGetPlaces } from '../model/requestGetPlaces';\nimport { RequestNewCity } from '../model/requestNewCity';\nimport { RequestNewCityDescription } from '../model/requestNewCityDescription';\nimport { RequestNewCityTravel } from '../model/requestNewCityTravel';\nimport { RequestNewPlace } from '../model/requestNewPlace';\nimport { RequestNewPlaceDescription } from '../model/requestNewPlaceDescription';\nimport { RequestNewPlaceEntry } from '../model/requestNewPlaceEntry';\nimport { RequestPublishCity } from '../model/requestPublishCity';\nimport { RequestPublishPlace } from '../model/requestPublishPlace';\nimport { RequestRemoveCityDescription } from '../model/requestRemoveCityDescription';\nimport { RequestRemoveCityTravel } from '../model/requestRemoveCityTravel';\nimport { RequestRemovePlaceDescription } from '../model/requestRemovePlaceDescription';\nimport { RequestRemovePlaceEntry } from '../model/requestRemovePlaceEntry';\nimport { RequestUpdateCityDescription } from '../model/requestUpdateCityDescription';\nimport { RequestUpdateCityTravel } from '../model/requestUpdateCityTravel';\nimport { RequestUpdatePlaceDescription } from '../model/requestUpdatePlaceDescription';\nimport { RequestUpdatePlaceEntry } from '../model/requestUpdatePlaceEntry';\nimport { ResponseData } from '../model/responseData';\nimport { ResponseDeleteCity } from '../model/responseDeleteCity';\nimport { ResponseDeletePlace } from '../model/responseDeletePlace';\nimport { ResponseGetCities } from '../model/responseGetCities';\nimport { ResponseGetCity } from '../model/responseGetCity';\nimport { ResponseGetPlace } from '../model/responseGetPlace';\nimport { ResponseGetPlaces } from '../model/responseGetPlaces';\nimport { ResponseNewCity } from '../model/responseNewCity';\nimport { ResponseNewCityDescription } from '../model/responseNewCityDescription';\nimport { ResponseNewCityTravel } from '../model/responseNewCityTravel';\nimport { ResponseNewPlace } from '../model/responseNewPlace';\nimport { ResponseNewPlaceDescription } from '../model/responseNewPlaceDescription';\nimport { ResponseNewPlaceEntry } from '../model/responseNewPlaceEntry';\nimport { ResponsePublishCity } from '../model/responsePublishCity';\nimport { ResponsePublishPlace } from '../model/responsePublishPlace';\nimport { ResponseRemoveCityDescription } from '../model/responseRemoveCityDescription';\nimport { ResponseRemoveCityTravel } from '../model/responseRemoveCityTravel';\nimport { ResponseRemovePlaceDescription } from '../model/responseRemovePlaceDescription';\nimport { ResponseRemovePlaceEntry } from '../model/responseRemovePlaceEntry';\nimport { ResponseUpdateCityDescription } from '../model/responseUpdateCityDescription';\nimport { ResponseUpdateCityTravel } from '../model/responseUpdateCityTravel';\nimport { ResponseUpdatePlaceDescription } from '../model/responseUpdatePlaceDescription';\nimport { ResponseUpdatePlaceEntry } from '../model/responseUpdatePlaceEntry';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocationsService {\n\n    protected basePath = 'http://localhost:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (basePath) {\n            this.basePath = basePath;\n        }\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = basePath || configuration.basePath || this.basePath;\n        }\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Delete a City\n     * Delete a City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCity(data: RequestDeleteCity, observe?: 'body', reportProgress?: boolean): Observable<ResponseDeleteCity>;\n    public deleteCity(data: RequestDeleteCity, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseDeleteCity>>;\n    public deleteCity(data: RequestDeleteCity, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseDeleteCity>>;\n    public deleteCity(data: RequestDeleteCity, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling deleteCity.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseDeleteCity>(`${this.basePath}/cities/delete`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a Place\n     * Delete a Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePlace(data: RequestDeletePlace, observe?: 'body', reportProgress?: boolean): Observable<ResponseDeletePlace>;\n    public deletePlace(data: RequestDeletePlace, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseDeletePlace>>;\n    public deletePlace(data: RequestDeletePlace, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseDeletePlace>>;\n    public deletePlace(data: RequestDeletePlace, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling deletePlace.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseDeletePlace>(`${this.basePath}/places/delete`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get all Cities\n     * Get all Cities, filtering by publish status\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCities(data: RequestGetCities, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetCities>;\n    public getCities(data: RequestGetCities, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetCities>>;\n    public getCities(data: RequestGetCities, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetCities>>;\n    public getCities(data: RequestGetCities, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getCities.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetCities>(`${this.basePath}/cities`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get City\n     * Get complete info of one City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCity(data: RequestGetCity, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetCity>;\n    public getCity(data: RequestGetCity, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetCity>>;\n    public getCity(data: RequestGetCity, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetCity>>;\n    public getCity(data: RequestGetCity, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getCity.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetCity>(`${this.basePath}/cities/city`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Place\n     * Get complete info of one Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPlace(data: RequestGetPlace, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetPlace>;\n    public getPlace(data: RequestGetPlace, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetPlace>>;\n    public getPlace(data: RequestGetPlace, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetPlace>>;\n    public getPlace(data: RequestGetPlace, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getPlace.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetPlace>(`${this.basePath}/places/place`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get all Places of a City\n     * Get all Places of a City filtering by publish status\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPlaces(data: RequestGetPlaces, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetPlaces>;\n    public getPlaces(data: RequestGetPlaces, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetPlaces>>;\n    public getPlaces(data: RequestGetPlaces, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetPlaces>>;\n    public getPlaces(data: RequestGetPlaces, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getPlaces.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetPlaces>(`${this.basePath}/places`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add new City\n     * Add new City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newCity(data: RequestNewCity, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewCity>;\n    public newCity(data: RequestNewCity, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewCity>>;\n    public newCity(data: RequestNewCity, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewCity>>;\n    public newCity(data: RequestNewCity, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newCity.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewCity>(`${this.basePath}/cities/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add description to City\n     * Add new description to existing City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newCityDescription(data: RequestNewCityDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewCityDescription>;\n    public newCityDescription(data: RequestNewCityDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewCityDescription>>;\n    public newCityDescription(data: RequestNewCityDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewCityDescription>>;\n    public newCityDescription(data: RequestNewCityDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newCityDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewCityDescription>(`${this.basePath}/cities/description/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add travel to City\n     * Add new travel to existing City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newCityTravel(data: RequestNewCityTravel, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewCityTravel>;\n    public newCityTravel(data: RequestNewCityTravel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewCityTravel>>;\n    public newCityTravel(data: RequestNewCityTravel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewCityTravel>>;\n    public newCityTravel(data: RequestNewCityTravel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newCityTravel.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewCityTravel>(`${this.basePath}/cities/travel/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add new Place\n     * Add new Place in existing City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newPlace(data: RequestNewPlace, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewPlace>;\n    public newPlace(data: RequestNewPlace, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewPlace>>;\n    public newPlace(data: RequestNewPlace, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewPlace>>;\n    public newPlace(data: RequestNewPlace, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newPlace.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewPlace>(`${this.basePath}/places/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add description to Place\n     * Add new description to existing Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newPlaceDescription(data: RequestNewPlaceDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewPlaceDescription>;\n    public newPlaceDescription(data: RequestNewPlaceDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewPlaceDescription>>;\n    public newPlaceDescription(data: RequestNewPlaceDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewPlaceDescription>>;\n    public newPlaceDescription(data: RequestNewPlaceDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newPlaceDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewPlaceDescription>(`${this.basePath}/places/description/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add Entry to Place\n     * Add new Entry to existing Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newPlaceEntry(data: RequestNewPlaceEntry, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewPlaceEntry>;\n    public newPlaceEntry(data: RequestNewPlaceEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewPlaceEntry>>;\n    public newPlaceEntry(data: RequestNewPlaceEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewPlaceEntry>>;\n    public newPlaceEntry(data: RequestNewPlaceEntry, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newPlaceEntry.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewPlaceEntry>(`${this.basePath}/places/entry/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Publish a City\n     * Publish the City content to readers\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public publishCity(data: RequestPublishCity, observe?: 'body', reportProgress?: boolean): Observable<ResponsePublishCity>;\n    public publishCity(data: RequestPublishCity, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePublishCity>>;\n    public publishCity(data: RequestPublishCity, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePublishCity>>;\n    public publishCity(data: RequestPublishCity, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling publishCity.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponsePublishCity>(`${this.basePath}/cities/publish`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Publish a Place\n     * Publish the Place content to readers\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public publishPlace(data: RequestPublishPlace, observe?: 'body', reportProgress?: boolean): Observable<ResponsePublishPlace>;\n    public publishPlace(data: RequestPublishPlace, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePublishPlace>>;\n    public publishPlace(data: RequestPublishPlace, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePublishPlace>>;\n    public publishPlace(data: RequestPublishPlace, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling publishPlace.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponsePublishPlace>(`${this.basePath}/places/publish`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove description from City\n     * Remove new description from existing City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeCityDescription(data: RequestRemoveCityDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseRemoveCityDescription>;\n    public removeCityDescription(data: RequestRemoveCityDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseRemoveCityDescription>>;\n    public removeCityDescription(data: RequestRemoveCityDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseRemoveCityDescription>>;\n    public removeCityDescription(data: RequestRemoveCityDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling removeCityDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseRemoveCityDescription>(`${this.basePath}/cities/description/remove`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove travel from City\n     * Remove new travel from existing City\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeCityTravel(data: RequestRemoveCityTravel, observe?: 'body', reportProgress?: boolean): Observable<ResponseRemoveCityTravel>;\n    public removeCityTravel(data: RequestRemoveCityTravel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseRemoveCityTravel>>;\n    public removeCityTravel(data: RequestRemoveCityTravel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseRemoveCityTravel>>;\n    public removeCityTravel(data: RequestRemoveCityTravel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling removeCityTravel.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseRemoveCityTravel>(`${this.basePath}/cities/travel/remove`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove description from Place\n     * Remove new description from existing Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removePlaceDescription(data: RequestRemovePlaceDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseRemovePlaceDescription>;\n    public removePlaceDescription(data: RequestRemovePlaceDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseRemovePlaceDescription>>;\n    public removePlaceDescription(data: RequestRemovePlaceDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseRemovePlaceDescription>>;\n    public removePlaceDescription(data: RequestRemovePlaceDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling removePlaceDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseRemovePlaceDescription>(`${this.basePath}/places/description/remove`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove entry from Place\n     * Remove new entry from existing Place\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removePlaceEntry(data: RequestRemovePlaceEntry, observe?: 'body', reportProgress?: boolean): Observable<ResponseRemovePlaceEntry>;\n    public removePlaceEntry(data: RequestRemovePlaceEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseRemovePlaceEntry>>;\n    public removePlaceEntry(data: RequestRemovePlaceEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseRemovePlaceEntry>>;\n    public removePlaceEntry(data: RequestRemovePlaceEntry, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling removePlaceEntry.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseRemovePlaceEntry>(`${this.basePath}/places/entry/remove`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update City description\n     * Update City description\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCityDescription(data: RequestUpdateCityDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdateCityDescription>;\n    public updateCityDescription(data: RequestUpdateCityDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdateCityDescription>>;\n    public updateCityDescription(data: RequestUpdateCityDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdateCityDescription>>;\n    public updateCityDescription(data: RequestUpdateCityDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updateCityDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdateCityDescription>(`${this.basePath}/cities/description/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update City travel\n     * Update City travel\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCityTravel(data: RequestUpdateCityTravel, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdateCityTravel>;\n    public updateCityTravel(data: RequestUpdateCityTravel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdateCityTravel>>;\n    public updateCityTravel(data: RequestUpdateCityTravel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdateCityTravel>>;\n    public updateCityTravel(data: RequestUpdateCityTravel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updateCityTravel.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdateCityTravel>(`${this.basePath}/cities/travel/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Place description\n     * Update Place description\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePlaceDescription(data: RequestUpdatePlaceDescription, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdatePlaceDescription>;\n    public updatePlaceDescription(data: RequestUpdatePlaceDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdatePlaceDescription>>;\n    public updatePlaceDescription(data: RequestUpdatePlaceDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdatePlaceDescription>>;\n    public updatePlaceDescription(data: RequestUpdatePlaceDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updatePlaceDescription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdatePlaceDescription>(`${this.basePath}/places/description/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Place entry\n     * Update Place entry\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePlaceEntry(data: RequestUpdatePlaceEntry, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdatePlaceEntry>;\n    public updatePlaceEntry(data: RequestUpdatePlaceEntry, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdatePlaceEntry>>;\n    public updatePlaceEntry(data: RequestUpdatePlaceEntry, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdatePlaceEntry>>;\n    public updatePlaceEntry(data: RequestUpdatePlaceEntry, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updatePlaceEntry.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdatePlaceEntry>(`${this.basePath}/places/entry/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * World_of_Stories-Api\n * Interactive stories application for NodeJs typescript server\n *\n * OpenAPI spec version: 1.0.0\n * \n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\n\nimport { Observable }                                        from 'rxjs';\n\nimport { RequestDeleteChapter } from '../model/requestDeleteChapter';\nimport { RequestDeleteNpc } from '../model/requestDeleteNpc';\nimport { RequestGetChapters } from '../model/requestGetChapters';\nimport { RequestGetNPC } from '../model/requestGetNPC';\nimport { RequestGetNpcs } from '../model/requestGetNpcs';\nimport { RequestNewNpc } from '../model/requestNewNpc';\nimport { RequestPublishChapter } from '../model/requestPublishChapter';\nimport { RequestPublishNpc } from '../model/requestPublishNpc';\nimport { RequestUpdateChapter } from '../model/requestUpdateChapter';\nimport { RequestUpdateNpc } from '../model/requestUpdateNpc';\nimport { ResponseData } from '../model/responseData';\nimport { ResponseDeleteChapter } from '../model/responseDeleteChapter';\nimport { ResponseDeleteNpc } from '../model/responseDeleteNpc';\nimport { ResponseGetChapters } from '../model/responseGetChapters';\nimport { ResponseGetNPC } from '../model/responseGetNPC';\nimport { ResponseGetNpcs } from '../model/responseGetNpcs';\nimport { ResponseNewNpc } from '../model/responseNewNpc';\nimport { ResponsePublishChapter } from '../model/responsePublishChapter';\nimport { ResponsePublishNpc } from '../model/responsePublishNpc';\nimport { ResponseUpdateChapter } from '../model/responseUpdateChapter';\nimport { ResponseUpdateNpc } from '../model/responseUpdateNpc';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StoriesService {\n\n    protected basePath = 'http://localhost:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (basePath) {\n            this.basePath = basePath;\n        }\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = basePath || configuration.basePath || this.basePath;\n        }\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Delete a Chapter\n     * Delete a Chapter, it will delete de option pointer to this chapter too\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteChapter(data: RequestDeleteChapter, observe?: 'body', reportProgress?: boolean): Observable<ResponseDeleteChapter>;\n    public deleteChapter(data: RequestDeleteChapter, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseDeleteChapter>>;\n    public deleteChapter(data: RequestDeleteChapter, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseDeleteChapter>>;\n    public deleteChapter(data: RequestDeleteChapter, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling deleteChapter.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseDeleteChapter>(`${this.basePath}/chapters/delete`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a NPC\n     * Delete a NPC\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteNpc(data: RequestDeleteNpc, observe?: 'body', reportProgress?: boolean): Observable<ResponseDeleteNpc>;\n    public deleteNpc(data: RequestDeleteNpc, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseDeleteNpc>>;\n    public deleteNpc(data: RequestDeleteNpc, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseDeleteNpc>>;\n    public deleteNpc(data: RequestDeleteNpc, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling deleteNpc.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseDeleteNpc>(`${this.basePath}/npcs/delete`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Chapters\n     * Get all Chapters of an Npc, filtering by publish status\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getChapters(data: RequestGetChapters, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetChapters>;\n    public getChapters(data: RequestGetChapters, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetChapters>>;\n    public getChapters(data: RequestGetChapters, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetChapters>>;\n    public getChapters(data: RequestGetChapters, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getChapters.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetChapters>(`${this.basePath}/chapters`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get NPC\n     * Get complete info of one NPC\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCity(data: RequestGetNPC, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetNPC>;\n    public getCity(data: RequestGetNPC, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetNPC>>;\n    public getCity(data: RequestGetNPC, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetNPC>>;\n    public getCity(data: RequestGetNPC, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getCity.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetNPC>(`${this.basePath}/npcs/npc`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get NPCs\n     * Get all NPC in array of IDs, filtering by publish status\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getNpcs(data: RequestGetNpcs, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetNpcs>;\n    public getNpcs(data: RequestGetNpcs, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetNpcs>>;\n    public getNpcs(data: RequestGetNpcs, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetNpcs>>;\n    public getNpcs(data: RequestGetNpcs, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getNpcs.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetNpcs>(`${this.basePath}/npcs`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add new NPC\n     * Add new NPC\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public newNpc(data: RequestNewNpc, observe?: 'body', reportProgress?: boolean): Observable<ResponseNewNpc>;\n    public newNpc(data: RequestNewNpc, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseNewNpc>>;\n    public newNpc(data: RequestNewNpc, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseNewNpc>>;\n    public newNpc(data: RequestNewNpc, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling newNpc.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseNewNpc>(`${this.basePath}/npcs/new`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Publish a Chapter\n     * Publish the Chapter content to readers\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public publishChapter(data: RequestPublishChapter, observe?: 'body', reportProgress?: boolean): Observable<ResponsePublishChapter>;\n    public publishChapter(data: RequestPublishChapter, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePublishChapter>>;\n    public publishChapter(data: RequestPublishChapter, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePublishChapter>>;\n    public publishChapter(data: RequestPublishChapter, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling publishChapter.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponsePublishChapter>(`${this.basePath}/chapters/publish`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Publish a Npc\n     * Publish the Npc content to readers\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public publishNpc(data: RequestPublishNpc, observe?: 'body', reportProgress?: boolean): Observable<ResponsePublishNpc>;\n    public publishNpc(data: RequestPublishNpc, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponsePublishNpc>>;\n    public publishNpc(data: RequestPublishNpc, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponsePublishNpc>>;\n    public publishNpc(data: RequestPublishNpc, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling publishNpc.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponsePublishNpc>(`${this.basePath}/npcs/publish`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Chapter\n     * Update Chapter information\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateChapter(data: RequestUpdateChapter, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdateChapter>;\n    public updateChapter(data: RequestUpdateChapter, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdateChapter>>;\n    public updateChapter(data: RequestUpdateChapter, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdateChapter>>;\n    public updateChapter(data: RequestUpdateChapter, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updateChapter.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdateChapter>(`${this.basePath}/chapters/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update NPC\n     * Update NPC\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateNpc(data: RequestUpdateNpc, observe?: 'body', reportProgress?: boolean): Observable<ResponseUpdateNpc>;\n    public updateNpc(data: RequestUpdateNpc, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseUpdateNpc>>;\n    public updateNpc(data: RequestUpdateNpc, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseUpdateNpc>>;\n    public updateNpc(data: RequestUpdateNpc, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling updateNpc.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseUpdateNpc>(`${this.basePath}/npcs/update`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * World_of_Stories-Api\n * Interactive stories application for NodeJs typescript server\n *\n * OpenAPI spec version: 1.0.0\n * \n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\n\nimport { Observable }                                        from 'rxjs';\n\nimport { RequestDeleteUser } from '../model/requestDeleteUser';\nimport { RequestGetUser } from '../model/requestGetUser';\nimport { RequestLogin } from '../model/requestLogin';\nimport { RequestRemoveRol } from '../model/requestRemoveRol';\nimport { RequestSetRol } from '../model/requestSetRol';\nimport { RequestSignin } from '../model/requestSignin';\nimport { ResponseData } from '../model/responseData';\nimport { ResponseDeleteUser } from '../model/responseDeleteUser';\nimport { ResponseGetUser } from '../model/responseGetUser';\nimport { ResponseGetUsers } from '../model/responseGetUsers';\nimport { ResponseLogin } from '../model/responseLogin';\nimport { ResponseRemoveRol } from '../model/responseRemoveRol';\nimport { ResponseSetRol } from '../model/responseSetRol';\nimport { ResponseSignin } from '../model/responseSignin';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UsersService {\n\n    protected basePath = 'http://localhost:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (basePath) {\n            this.basePath = basePath;\n        }\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = basePath || configuration.basePath || this.basePath;\n        }\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * Delete an User\n     * Delete an user\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUser(data: RequestDeleteUser, observe?: 'body', reportProgress?: boolean): Observable<ResponseDeleteUser>;\n    public deleteUser(data: RequestDeleteUser, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseDeleteUser>>;\n    public deleteUser(data: RequestDeleteUser, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseDeleteUser>>;\n    public deleteUser(data: RequestDeleteUser, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling deleteUser.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseDeleteUser>(`${this.basePath}/users/delete`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an User\n     * Get an user\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUser(data: RequestGetUser, observe?: 'body', reportProgress?: boolean): Observable<ResponseGetUser>;\n    public getUser(data: RequestGetUser, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetUser>>;\n    public getUser(data: RequestGetUser, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetUser>>;\n    public getUser(data: RequestGetUser, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling getUser.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseGetUser>(`${this.basePath}/users/user`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get All Users\n     * Get all Users\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUsers(observe?: 'body', reportProgress?: boolean): Observable<ResponseGetUsers>;\n    public getUsers(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseGetUsers>>;\n    public getUsers(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseGetUsers>>;\n    public getUsers(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n\n        return this.httpClient.get<ResponseGetUsers>(`${this.basePath}/users`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Login User\n     * login user\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public login(data: RequestLogin, observe?: 'body', reportProgress?: boolean): Observable<ResponseLogin>;\n    public login(data: RequestLogin, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseLogin>>;\n    public login(data: RequestLogin, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseLogin>>;\n    public login(data: RequestLogin, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling login.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseLogin>(`${this.basePath}/users/login`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove User Rol\n     * Remove new rol to an User\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeRol(data: RequestRemoveRol, observe?: 'body', reportProgress?: boolean): Observable<ResponseRemoveRol>;\n    public removeRol(data: RequestRemoveRol, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseRemoveRol>>;\n    public removeRol(data: RequestRemoveRol, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseRemoveRol>>;\n    public removeRol(data: RequestRemoveRol, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling removeRol.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseRemoveRol>(`${this.basePath}/users/remove_rol`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Set User Rol\n     * Set new rol to an User\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public setRol(data: RequestSetRol, observe?: 'body', reportProgress?: boolean): Observable<ResponseSetRol>;\n    public setRol(data: RequestSetRol, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseSetRol>>;\n    public setRol(data: RequestSetRol, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseSetRol>>;\n    public setRol(data: RequestSetRol, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling setRol.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseSetRol>(`${this.basePath}/users/set_rol`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Sign in new User\n     * Sign in new user\n     * @param data Transaction details\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public signin(data: RequestSignin, observe?: 'body', reportProgress?: boolean): Observable<ResponseSignin>;\n    public signin(data: RequestSignin, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ResponseSignin>>;\n    public signin(data: RequestSignin, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ResponseSignin>>;\n    public signin(data: RequestSignin, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        if (data === null || data === undefined) {\n            throw new Error('Required parameter data was null or undefined when calling signin.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        let httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected != undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected != undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<ResponseSignin>(`${this.basePath}/users/signin`,\n            data,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n"],"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","BASE_PATH","InjectionToken","Configuration","prototype","selectHeaderContentType","contentTypes","_this","this","undefined","type","find","x","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","configurationParameters","apiKeys","username","password","accessToken","basePath","withCredentials","LocationsService","canConsumeForm","consumes","consumes_1","tslib_1.__values","consumes_1_1","deleteCity","data","observe","reportProgress","Error","headers","defaultHeaders","httpHeaderAcceptSelected","configuration","set","httpContentTypeSelected","httpClient","post","deletePlace","getCities","getCity","getPlace","getPlaces","newCity","newCityDescription","newCityTravel","newPlace","newPlaceDescription","newPlaceEntry","publishCity","publishPlace","removeCityDescription","removeCityTravel","removePlaceDescription","removePlaceEntry","updateCityDescription","updateCityTravel","updatePlaceDescription","updatePlaceEntry","Injectable","args","providedIn","HttpClient","Optional","Inject","decorators","HttpHeaders","StoriesService","deleteChapter","deleteNpc","getChapters","getNpcs","newNpc","publishChapter","publishNpc","updateChapter","updateNpc","UsersService","deleteUser","getUser","getUsers","get","login","removeRol","setRol","signin"],"mappings":"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"}